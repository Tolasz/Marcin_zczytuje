const w={keyboard:{left:["ArrowLeft","KeyA"],right:["ArrowRight","KeyD"],up:["ArrowUp","KeyW"],down:["ArrowDown","KeyS"],jump:["Space","KeyW","ArrowUp"],pause:["KeyP","Escape"],confirm:["Enter","Space"],gameOver:["KeyG"]},gamepad:{deadZone:.2,horizontalAxis:0,verticalAxis:1,jumpButtons:[0],pauseButtons:[9]},pointer:{enabled:!0,jumpTapMaxMs:220,dragDeadZonePx:24}};class l{config;keysDown=new Set;pointerActive=!1;pointerStartX=0;pointerX=0;pointerDownAtMs=0;queuedJump=!1;virtualLeftDown=!1;virtualRightDown=!1;constructor(e){this.config=d(w,e??{})}attach(){window.addEventListener("keydown",this.onKeyDown),window.addEventListener("keyup",this.onKeyUp),this.config.pointer.enabled&&(window.addEventListener("pointerdown",this.onPointerDown,{passive:!0}),window.addEventListener("pointermove",this.onPointerMove,{passive:!0}),window.addEventListener("pointerup",this.onPointerUp,{passive:!0}),window.addEventListener("pointercancel",this.onPointerUp,{passive:!0}))}detach(){window.removeEventListener("keydown",this.onKeyDown),window.removeEventListener("keyup",this.onKeyUp),this.keysDown.clear(),this.config.pointer.enabled&&(window.removeEventListener("pointerdown",this.onPointerDown),window.removeEventListener("pointermove",this.onPointerMove),window.removeEventListener("pointerup",this.onPointerUp),window.removeEventListener("pointercancel",this.onPointerUp)),this.pointerActive=!1,this.queuedJump=!1}snapshot(){const e=this.config.keyboard,o={x:s(e.left,this.keysDown)?-1:s(e.right,this.keysDown)?1:0,y:s(e.up,this.keysDown)?-1:s(e.down,this.keysDown)?1:0},n=navigator.getGamepads?.().find(r=>!!r&&r.connected&&!r.mapping),i=n?y({x:n.axes[this.config.gamepad.horizontalAxis]??0,y:n.axes[this.config.gamepad.verticalAxis]??0},this.config.gamepad.deadZone):{x:0,y:0};let a=0;if(this.config.pointer.enabled&&this.pointerActive){const r=this.pointerX-this.pointerStartX;if(Math.abs(r)>=this.config.pointer.dragDeadZonePx)a=u(r/120,-1,1);else{const f=(typeof window<"u"?window.innerWidth:0)/2;a=this.pointerX<f?-1:1}}let p=0;this.virtualLeftDown&&(p-=1),this.virtualRightDown&&(p+=1);const h=m({x:o.x+i.x+a+p,y:o.y+i.y}),c={Jump:s(e.jump,this.keysDown)||(n?this.config.gamepad.jumpButtons.some(r=>!!n.buttons[r]?.pressed):!1)||this.consumeQueuedJump(),Pause:s(e.pause,this.keysDown)||(n?this.config.gamepad.pauseButtons.some(r=>!!n.buttons[r]?.pressed):!1),Confirm:s(e.confirm,this.keysDown),GameOver:s(e.gameOver,this.keysDown)};return{move:h,actions:c}}onKeyDown=e=>{this.keysDown.add(e.code)};onKeyUp=e=>{this.keysDown.delete(e.code)};onPointerDown=e=>{e.isPrimary!==!1&&(this.pointerActive=!0,this.pointerStartX=e.clientX,this.pointerX=e.clientX,this.pointerDownAtMs=typeof performance<"u"?performance.now():Date.now())};onPointerMove=e=>{!this.pointerActive||e.isPrimary===!1||(this.pointerX=e.clientX)};onPointerUp=e=>{if(e.isPrimary===!1)return;const n=(typeof performance<"u"?performance.now():Date.now())-this.pointerDownAtMs,i=Math.abs(this.pointerX-this.pointerStartX);n<=this.config.pointer.jumpTapMaxMs&&i<this.config.pointer.dragDeadZonePx&&(this.queuedJump=!0),this.pointerActive=!1};consumeQueuedJump(){const e=this.queuedJump;return this.queuedJump=!1,e}setVirtualLeftDown(e){this.virtualLeftDown=!!e}setVirtualRightDown(e){this.virtualRightDown=!!e}queueJump(){this.queuedJump=!0}}function s(t,e){for(const o of t)if(e.has(o))return!0;return!1}function m(t){const e=Math.hypot(t.x,t.y);return e<=1?{x:u(t.x,-1,1),y:u(t.y,-1,1)}:{x:t.x/e,y:t.y/e}}function u(t,e,o){return Math.min(o,Math.max(e,t))}function y(t,e){const o=Math.abs(t.x)<e?0:t.x,n=Math.abs(t.y)<e?0:t.y;return{x:o,y:n}}function d(t,e){if(e==null)return t;const o=Array.isArray(t)?[...t]:{...t};for(const[n,i]of Object.entries(e))i&&typeof i=="object"&&!Array.isArray(i)?o[n]=d(t[n],i):i!==void 0&&(o[n]=i);return o}export{l as InputSystem,l as default};
