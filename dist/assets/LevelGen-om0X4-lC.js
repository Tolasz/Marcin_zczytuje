import{createRectPlatform as P}from"./Platform-DpA5G9Ud.js";import{d as b}from"./Player-BgmGi5Hd.js";import{o as C,n as o}from"./types-0I2BUTGt.js";const R=C({seed:o().int(),screenWidth:o().int().positive(),platformWidth:o().int().positive(),verticalGapMin:o().int().positive(),verticalGapMax:o().int().positive(),jitterX:o().int().nonnegative().default(40),moveSpeed:o().positive().default(b.moveSpeed),jumpVelocity:o().default(b.jumpVelocity),gravity:o().positive().default(b.gravity),momentumJumpMultiplier:o().nonnegative().default(b.momentumJumpMultiplier)});function X(k){let c=k>>>0;return function(){c+=1831565813;let e=Math.imul(c^c>>>15,1|c);return e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}}class q{rand;cfg;nextSpawnY;lastPlatform=null;constructor(c){const f=R.parse(c);this.cfg=f,this.rand=X(f.seed),this.nextSpawnY=c.startY}spawnUntil(c){const f=[];for(;this.nextSpawnY>c;){const e=!this.lastPlatform;let m=this.cfg.verticalGapMin+Math.floor(this.rand()*Math.max(1,this.cfg.verticalGapMax-this.cfg.verticalGapMin));if(e){const i=Math.abs(this.cfg.jumpVelocity),a=this.cfg.gravity,r=Math.floor(i*i/(2*a)),h=Math.max(40,r-8);m>h&&(m=h)}this.nextSpawnY-=m;const w=9,W=this.cfg.platformWidth,S=Math.max(56,Math.floor(W*.6)),G=Math.max(S,Math.min(this.cfg.screenWidth,Math.floor(W*1.4)));let l=S+Math.floor(this.rand()*Math.max(1,G-S));if(e){const i=Math.min(this.cfg.screenWidth,Math.floor(W*1.2));l<i&&(l=i)}let p=0,d=Math.max(0,this.cfg.screenWidth-l);if(this.lastPlatform){const i=this.cfg.moveSpeed,a=Math.abs(this.cfg.jumpVelocity)*(1+this.cfg.momentumJumpMultiplier),r=this.cfg.gravity,M=a*a/(2*r);if(m>M-1){const v=m-Math.floor(M-1);m-=v,this.nextSpawnY+=v}const h=a*a-2*r*m,j=h>0?(a-Math.sqrt(Math.max(0,h)))/r:0,x=Math.max(0,i*j),g=this.lastPlatform,y=g.x-x,Y=g.x+g.w+x;if(p=Math.max(0,Math.floor(y-l)),d=Math.min(Math.max(0,this.cfg.screenWidth-l),Math.floor(Y)),p>d){const v=(y+Y-l)/2,O=Math.max(0,Math.min(this.cfg.screenWidth-l,Math.floor(v)));p=O,d=O}}const V=e?Math.floor((this.cfg.screenWidth-l)/2):p===d?p:p+Math.floor(this.rand()*Math.max(1,d-p)),s=this.rand();let t="static";e||(s<.06?t="moving":s<.1?t="bouncy":s<.13?t="conveyor":s<.16?t="crumble":s<.19?t="falling":s<.22?t="ice":s<.25?t="sticky":s<.28?t="vanish":s<.31&&(t="breakable"));const n={oneWay:!0,type:t};t==="moving"?Object.assign(n,{axis:s<.5?"x":"y",amplitude:60,cycleMs:2e3}):t==="conveyor"?Object.assign(n,{conveyorSpeed:(this.rand()<.5?-1:1)*60}):t==="bouncy"?Object.assign(n,{bounceMultiplier:1.35}):t==="ice"?Object.assign(n,{frictionAlpha:.15}):t==="sticky"?Object.assign(n,{frictionAlpha:.9,speedMultiplier:.7}):t==="vanish"?Object.assign(n,{cycleMs:1600,dutyCycle:.5}):t==="falling"?Object.assign(n,{delayMs:200,fallSpeed:260}):t==="crumble"?Object.assign(n,{crumbleDelayMs:450}):t==="breakable"&&Object.assign(n,{hitPoints:1});const u=P(V,this.nextSpawnY,l,w,n);if(f.push(u),this.lastPlatform=u,!e&&this.rand()<.02){const i=u.w,a=Math.max(56,Math.floor(i*.3)),r=24,M=Math.max(0,i-a);if(M>=r){const h=Math.floor(r+this.rand()*Math.max(1,M-r)),j=Math.floor(a+this.rand()*Math.max(1,i-h-a)),x=u.x+j,g=u.y,y=P(x,g,h,w,{type:"spike",oneWay:!1});f.push(y)}}}return f}}export{R as LevelSchema,q as VerticalSpawner,X as mulberry32};
